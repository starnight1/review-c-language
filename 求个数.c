/****算法就是错误的
# include <stdio.h>
void main()
{
	int i,j,k,m=0;
	for(i=1;i<5;i++)
	{
		for(j=1;j<5&&j!=i;j++)//这样写是错的！因为当i=1再j=1时，条件不满足，直接百位数（i）从2继续循环，123的可能性就没了
		{
			for(k=1;k<5 && k!=i && k!=j;k++)//所以应该从最里层循环开始判断条件不满足自增，即应在最后判断是否重复
			{
				printf("%d%d%d\n",i,j,k);
				m++;
			}
		}
	}

}
*/



/*算法正确，但是小错误太多
# include <stdio.h>
void main()
{
	int i,j,k,m=0;
	for(i=1;i<5;i++)
	{
		for(j=1;j<5;j++)
		{
			if(j==i)//这儿写成j=i则打错特错，因为这是赋值语句，其值总是真，则永远不会执行下面的语句。经典错误！！！
				continue;//不应该是break，应该是continue
			for(k=1;k<5;k++)
			{
				if(k==i||k==j)//（不可以写成k=j,因为这是赋值语句，）最主要的问题是赋值运算符的优先级
							//低于||，则先运算i||k，再赋值给k，完全曲解了意思。所以，要么加括号变为：((k=i)||(k=j))，要么用关系运算符==变为（k==i||k==j）
					continue;
				printf("%d%d%d\n",i,j,k);
				m++;
			}
		}
	}
	printf("%d\n",m);//一般来说个数总是在最后执行，而不是在循环体中
}
*/


/*参考答案，较为简洁,值得借鉴*/

 
# include <stdio.h>
void main()
{
	int i,j,k,m=0;
	for(i=1;i<5;i++)
	{
		for(j=1;j<5;j++)//这样写是错的！因为当i=1再j=1时，条件不满足，直接百位数（i）从2继续循环，123的可能性就没了
		{
			for(k=1;k<5 ;k++)//所以应该从最里层循环开始判断条件不满足自增，即应在最后判断是否重复
			{
				if(i!=k && i!=j && j!=k)
				{
					printf("%d%d%d\n",i,j,k);	
					m++;
				}
			}
		}
	}
	printf("%d\n",m);
}
